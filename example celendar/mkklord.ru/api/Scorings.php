<?php
/**
 * Extension for Simpla
 * File is autogenerated 24.07.2020 11:32:16 by CRUD 
 * @author Ruslan Kopyl
 */
require_once 'Simpla.php';

class Scorings extends Simpla
{
    // region Типы скорингов (Id)
    public const TYPE_SCORISTA = 1;
    public const TYPE_FMS = 2;
    public const TYPE_FSSP = 3;
    public const TYPE_FNS = 4;
    public const TYPE_LOCAL_TIME = 5;
    public const TYPE_LOCATION = 6;
    public const TYPE_JUICESCORE = 7;
    public const TYPE_BLACKLIST = 8;
    public const TYPE_EFRSB = 9;
    public const TYPE_AGE = 11;
    public const TYPE_SVO = 12;
    public const TYPE_AXILINK = 13;
    public const TYPE_WEBMASTER = 14;
    public const TYPE_DBRAIN_PASSPORT = 15;
    public const TYPE_DBRAIN_CARD = 16;
    public const TYPE_AXILINK_2 = 17;
    public const TYPE_PDN = 18;
    public const TYPE_FINKARTA = 19;
    public const TYPE_UPRID = 20;
    public const TYPE_PYTON_NBKI = 21;
    public const TYPE_PYTON_SMP = 22;
    public const TYPE_MEGAFON = 23;
    public const TYPE_MTS = 24;
    public const TYPE_EGRUL = 25;
    public const TYPE_WORK = 26;
    public const TYPE_REPORT = 27;
    public const TYPE_CYBERITY = 28;
    public const TYPE_LOCATION_IP = 29;
    // endregion

    // region Статусы скорингов (Id)

    /** @var int Новый скоринг, ждёт своей очереди */
    public const STATUS_NEW = 1;

    /** @var int Скоринг обрабатывается */
    public const STATUS_PROCESS = 2;

    /** @var int Скоринг остановлен досрочно */
    public const STATUS_STOPPED = 3;

    /** @var int Завершённый скоринг */
    public const STATUS_COMPLETED = 4;

    /** @var int Скоринг не прошёл из-за ошибки */
    public const STATUS_ERROR = 5;

    public const STATUS_IMPORT = 6;

    /** @var int Скоринг обрабатывается */
    public const STATUS_WAIT = 7;

    /** @var array Соответствие названия статуса и его id, для обратной совместимости */
    public const STATUSES = [
        'new' => self::STATUS_NEW,
        'process' => self::STATUS_PROCESS,
        'stopped' => self::STATUS_STOPPED,
        'completed' => self::STATUS_COMPLETED,
        'error' => self::STATUS_ERROR,
        'import' => self::STATUS_IMPORT,
        'wait' => self::STATUS_WAIT
    ];
    // endregion

    /** @var array Список скорингов для НК, статус которых проверяется при проверке возможности добавления скористы и акси */
    private const REQUIRED_FOR_SCORISTA_NK = [
        // При изменении списка его нужно обновить и на сайте
        self::TYPE_AGE,
        self::TYPE_LOCATION,
        self::TYPE_BLACKLIST,
        self::TYPE_FNS,
        self::TYPE_EFRSB,
        self::TYPE_LOCATION_IP,

        // Проверяем скористу и акси, чтобы убедиться что их ещё нет
        self::TYPE_SCORISTA,
        self::TYPE_AXILINK_2
    ];

    /** @var array Список скорингов для ПК, статус которых проверяется при проверке возможности добавления скористы и акси */
    private const REQUIRED_FOR_SCORISTA_PK = [
        // При изменении списка его нужно обновить и на сайте
        self::TYPE_AGE,
        self::TYPE_LOCATION,
        self::TYPE_BLACKLIST,
        self::TYPE_FNS,
        self::TYPE_EFRSB,

        // Проверяем скористу и акси, чтобы убедиться что их ещё нет
        self::TYPE_SCORISTA,
        self::TYPE_AXILINK_2
    ];

    /**
     * Причины отказа по стоп-фактору.
     *
     * **Должны быть синхронизированы с CRM**
     * `scorings/DbrainAxi.php::REJECT_REASONS`
     */
    public const AXI_REJECT_REASONS = [
        'SSP_SELFDEC'   => Reasons::REASON_SELF_DEC, // Самозапрет
        'FNS_NOTFOUND'  => Reasons::REASON_INN_NOT_FOUND, // Акси не смог найти ИНН
        'IDX_SCOR'      => Reasons::REASON_AXI_IDX,
        'FSSP_SUM'      => Reasons::REASON_AXI_FSSP,
        'BAD_DEVICE'    => Reasons::REASON_AXI_BAD_DEVICE,
        'CNT_ACT_CH'    => Reasons::REASON_AXI_CNT_ACT_CH,
        'SCORE_CUTOFF'  => Reasons::REASON_AXI_SCORE,
    ];

    /**
     * Get last scoring of user
     * @param int $userId
     * @return false|int|object
     */
    public function getLastScoringOfUser(int $userId)
    {
        $this->db->query($this->db->placehold(
            "SELECT * FROM __scorings WHERE `type` IN(?@) AND user_id = ? AND status = ? ORDER BY id DESC",
            [self::TYPE_SCORISTA, self::TYPE_AXILINK],
            $userId,
            self::STATUS_COMPLETED
        ));
        return $this->db->result();
    }

    public function get_scoring($id, string $table_name = 's_scorings')
    {
        $query = $this->db->placehold("
            SELECT sc.*,
                   sct.name AS type_name
            FROM $table_name sc
            LEFT JOIN __scoring_types sct ON sc.type = sct.id
            WHERE sc.id = ?
        ", (int)$id);
        $this->db->query($query);
        $result = $this->db->result();

        if (!empty($result)) {
            $result->body = $this->get_scoring_body($id);
            $result->status_name = self::STATUSES[$result->status] ?? '';
        }

        return $result;
    }
    
	public function get_scorings($filter = array())
	{
		$id_filter = '';
 		$user_id_filter = '';
        $order_id_filter = '';
        $status_filter = '';
        $type_filter = '';
        $keyword_filter = '';
        $limit = 1000;
		$page = 1;
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND sc.id IN (?@)", array_map('intval', (array)$filter['id']));

        if (!empty($filter['status']))
            $status_filter = $this->db->placehold("AND sc.status IN (?@)", (array)$filter['status']);

        if (!empty($filter['type']))
            $type_filter = $this->db->placehold("AND sc.type IN (?@)", (array)$filter['type']);

        if (!empty($filter['user_id']))
            $user_id_filter = $this->db->placehold("AND sc.user_id IN (?@)", array_map('intval', (array)$filter['user_id']));

        if (!empty($filter['order_id']))
            $order_id_filter = $this->db->placehold("AND sc.order_id IN (?@)", array_map('intval', (array)$filter['order_id']));

		if(isset($filter['keyword']))
		{
			$keywords = explode(' ', $filter['keyword']);
			foreach($keywords as $keyword)
				$keyword_filter .= $this->db->placehold('AND (sc.name LIKE "%'.$this->db->escape(trim($keyword)).'%" )');
		}
        
		if(isset($filter['limit']))
			$limit = max(1, intval($filter['limit']));

		if(isset($filter['page']))
			$page = max(1, intval($filter['page']));
            
        $sql_limit = $this->db->placehold(' LIMIT ?, ? ', ($page-1)*$limit, $limit);

        $query = $this->db->placehold("
            SELECT 
                sc.id, 
                sc.user_id,
                sc.order_id,
                sc.type,
                sct.name AS type_name,
                sc.status,
                sc.success,
                sc.created,
                sc.scorista_id,
                sc.string_result 
            FROM __scorings sc
            LEFT JOIN __scoring_types sct ON sc.type = sct.id
            WHERE 1
                $id_filter
                $status_filter
                $type_filter
                $user_id_filter
                $order_id_filter
                $keyword_filter
            ORDER BY sc.id DESC 
            $sql_limit
        ");
        $this->db->query($query);
        $results = $this->db->results();

        if (!empty($results)) {
            foreach ($results as &$result) {
                $result->status_name = self::STATUSES[$result->status] ?? '';
            }
        }

        return $results;
	}
    
	public function count_scorings($filter = array())
	{
        $id_filter = '';
        $user_id_filter = '';
        $keyword_filter = '';
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND id IN (?@)", array_map('intval', (array)$filter['id']));
		
        if (!empty($filter['user_id']))
            $user_id_filter = $this->db->placehold("AND user_id IN (?@)", array_map('intval', (array)$filter['user_id']));
        
        if(isset($filter['keyword']))
		{
			$keywords = explode(' ', $filter['keyword']);
			foreach($keywords as $keyword)
				$keyword_filter .= $this->db->placehold('AND (name LIKE "%'.$this->db->escape(trim($keyword)).'%" )');
		}
                
		$query = $this->db->placehold("
            SELECT COUNT(id) AS count
            FROM __scorings
            WHERE 1
                $id_filter
                $user_id_filter
                $keyword_filter
        ");
        $this->db->query($query);
        $count = $this->db->result('count');
	
        return $count;
    }

    public function add_scoring($scoring)
    {
        $scoring = (array)$scoring;
        if (!empty($scoring['body'])) {
            $body = $scoring['body'];
        }
        unset($scoring['body']);

        if (empty($scoring['status']))
            $scoring['status'] = self::STATUS_NEW;

        $query = $this->db->placehold("INSERT INTO __scorings SET ?%", $scoring);
        $this->db->query($query);

        $id = $this->db->insert_id();
        if (!empty($body))
            $this->add_scoring_body($id, $body);
        return $id;
    }

    public function update_scoring($id, $scoring)
    {
        $scoring = (array)$scoring;
        if (!empty($scoring['body'])) {
            if (!empty($this->get_scoring_body($id)))
                $this->update_scoring_body($id, $scoring['body']);
            else
                $this->add_scoring_body($id, $scoring['body']);
        }
        unset($scoring['body']);

        $query = $this->db->placehold("
            UPDATE __scorings SET ?% WHERE id = ?
        ", $scoring, (int)$id);
        $this->db->query($query);

        return $id;
    }
    
    public function delete_scoring($id)
    {
		$query = $this->db->placehold("
            DELETE FROM __scorings WHERE id = ?
        ", (int)$id);
        $this->db->query($query);
    }

    public function get_reason($scoring_type)
    {
    	$reasons = array(
            'local_time' => 'По вашей заявке поступил отказ по причине вашей большой финансовой нагрузки, для получения более подробной консультации можете позвонить 8 800 333 30 73, с уважением Boostra',
            'location' => 'По вашей заявке поступил отказ по причине вашей большой финансовой нагрузки, для получения более подробной консультации можете позвонить 8 800 333 30 73, с уважением Boostra',
            'fms' => 'По вашей заявке поступил отказ по причине ответа ФМС о недействительности паспортных данных, для получения более подробной консультации можете позвонить 8 800 333 30 73, с уважением Boostra',
            'fssp' => 'По вашей заявке поступил отказ по причине имеющихся задолженностей у ФССП, для получения более подробной консультации можете позвонить 8 800 333 30 73, с уважением Boostra',
        );
        
        if (isset($reasons[$scoring_type]))
            return $reasons[$scoring_type];
    }
    
    
    /** Scoring types **/
    public function get_type($id)
	{
        $where = is_int($id) ? $this->db->placehold("WHERE id = ?", (int)$id) : $this->db->placehold("WHERE name = ?", (string)$id);
        
		$query = $this->db->placehold("
            SELECT * 
            FROM __scoring_types
            $where
        ");
        $this->db->query($query);
        if ($result = $this->db->result())
            $result->params = unserialize($result->params);
	
        return $result;
    }
    
	public function get_types($filter = array())
	{
		$id_filter = '';
        $active_filter = '';
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND id IN (?@)", array_map('intval', (array)$filter['id']));
        
        if (isset($filter['active']))
            $active_filter = $this->db->placehold("AND active = ?", (int)$filter['active']);
        
        $query = $this->db->placehold("
            SELECT * 
            FROM __scoring_types
            WHERE 1
                $id_filter
                $active_filter
            ORDER BY position ASC 
        ");
        $this->db->query($query);
        if ($results = $this->db->results())
        {
            foreach ($results as $result)
                $result->params = unserialize($result->params);
        }
        
        return $results;
	}
    
	public function count_types($filter = array())
	{
        $id_filter = '';
        $active_filter = '';
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND id IN (?@)", array_map('intval', (array)$filter['id']));
        
        if (isset($filter['active']))
            $active_filter = $this->db->placehold("AND active = ?", (int)$filter['active']);
        
		$query = $this->db->placehold("
            SELECT COUNT(id) AS count
            FROM __scoring_types
            WHERE 1
                $id_filter
                $active_filter
        ");
        $this->db->query($query);
        $count = $this->db->result('count');
	
        return $count;
    }
    
    public function add_type($type)
    {
        $type = (array)$type;
        
        if (isset($type['params']))
            $type['params'] = serialize($type['params']);
        
		$query = $this->db->placehold("
            INSERT INTO __scoring_types SET ?%
        ", $type);
        $this->db->query($query);
        $id = $this->db->insert_id();
        
        return $id;
    }
    
    public function update_type($id, $type)
    {
        $type = (array)$type;
        
        if (isset($type['params']))
            $type['params'] = serialize($type['params']);
            
		$query = $this->db->placehold("
            UPDATE __scoring_types SET ?% WHERE id = ?
        ", $type, (int)$id);
        $this->db->query($query);
        
        return $id;
    }
    
    public function delete_type($id)
    {
		$query = $this->db->placehold("
            DELETE FROM __scoring_types WHERE id = ?
        ", (int)$id);
        $this->db->query($query);
    }


    /** Audit **/
    public function get_audit($id)
	{
		$query = $this->db->placehold("
            SELECT * 
            FROM __audits
            WHERE id = ?
        ", (int)$id);
        $this->db->query($query);
        if ($result = $this->db->result())
            $result->types = unserialize($result->types);
	   
        return $result;
    }
    
	public function get_audits($filter = array())
	{
		$id_filter = '';
 		$user_id_filter = '';
 		$order_id_filter = '';
 		$status_filter = '';
        $keyword_filter = '';
        $limit = 1000;
		$page = 1;
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND id IN (?@)", array_map('intval', (array)$filter['id']));
        
        if (!empty($filter['user_id']))
            $user_id_filter = $this->db->placehold("AND user_id IN (?@)", array_map('intval', (array)$filter['user_id']));
            
        if (!empty($filter['order_id']))
            $order_id_filter = $this->db->placehold("AND order_id IN (?@)", array_map('intval', (array)$filter['order_id']));
        
        if (!empty($filter['status']))
            $status_filter = $this->db->placehold("AND status = ?", (string)$filter['status']);
        
		if(isset($filter['keyword']))
		{
			$keywords = explode(' ', $filter['keyword']);
			foreach($keywords as $keyword)
				$keyword_filter .= $this->db->placehold('AND (name LIKE "%'.$this->db->escape(trim($keyword)).'%" )');
		}
        
		if(isset($filter['limit']))
			$limit = max(1, intval($filter['limit']));

		if(isset($filter['page']))
			$page = max(1, intval($filter['page']));
            
        $sql_limit = $this->db->placehold(' LIMIT ?, ? ', ($page-1)*$limit, $limit);

        $query = $this->db->placehold("
            SELECT * 
            FROM __audits
            WHERE 1
                $id_filter
                $user_id_filter
                $order_id_filter
                $status_filter
                $keyword_filter
            ORDER BY id ASC 
            $sql_limit
        ");
        $this->db->query($query);
        if ($results = $this->db->results())
        {
            foreach ($results as $result)
                $result->types = unserialize($result->types);
        }
        return $results;
	}
    
	public function count_audits($filter = array())
	{
        $id_filter = '';
        $user_id_filter = '';
        $order_id_filter = '';
        $status_filter = '';
        $keyword_filter = '';
        
        if (!empty($filter['id']))
            $id_filter = $this->db->placehold("AND id IN (?@)", array_map('intval', (array)$filter['id']));
		
        if (!empty($filter['user_id']))
            $user_id_filter = $this->db->placehold("AND user_id IN (?@)", array_map('intval', (array)$filter['user_id']));
            
        if (!empty($filter['order_id']))
            $order_id_filter = $this->db->placehold("AND order_id IN (?@)", array_map('intval', (array)$filter['order_id']));
        
        if (!empty($filter['status']))
            $status_filter = $this->db->placehold("AND status = ?", (string)$filter['status']);
        
        if(isset($filter['keyword']))
		{
			$keywords = explode(' ', $filter['keyword']);
			foreach($keywords as $keyword)
				$keyword_filter .= $this->db->placehold('AND (name LIKE "%'.$this->db->escape(trim($keyword)).'%" )');
		}
                
		$query = $this->db->placehold("
            SELECT COUNT(id) AS count
            FROM __audits
            WHERE 1
                $id_filter
                $user_id_filter
                $order_id_filter
                $status_filter
                $keyword_filter
        ");
        $this->db->query($query);
        $count = $this->db->result('count');
	
        return $count;
    }
    
    public function add_audit($audit)
    {
        $audit = (array)$audit;
        
        if (isset($audit['types']))
            $audit['types'] = serialize($audit['types']);
        
		$query = $this->db->placehold("
            INSERT INTO __audits SET ?%
        ", $audit);
        $this->db->query($query);
        $id = $this->db->insert_id();
        
        return $id;
    }
    
    public function update_audit($id, $audit)
    {
        $audit = (array)$audit;
        
        if (isset($audit['types']))
            $audit['types'] = serialize($audit['types']);
        
		$query = $this->db->placehold("
            UPDATE __audits SET ?% WHERE id = ?
        ", $audit, (int)$id);
        $this->db->query($query);
        
        return $id;
    }
    
    public function delete_audit($id)
    {
		$query = $this->db->placehold("
            DELETE FROM __audits WHERE id = ?
        ", (int)$id);
        $this->db->query($query);
    }

    public function get_last_scorista_for_user($user_id, $only_completed = false)
    {
        $where_completed = '';
        if ($only_completed)
        {
            $where_completed = "AND status = " . self::STATUS_COMPLETED;
        }

        $query = $this->db->placehold("
            SELECT * FROM __scorings WHERE type IN(?@) AND user_id = ? $where_completed ORDER BY id DESC LIMIT 1
        ", [self::TYPE_SCORISTA, self::TYPE_AXILINK], $user_id);

        $this->db->query($query);

        return $this->db->result();
    }

    /**
     * Получает цвет для балла скористы
     * @param $score
     * @return array
     */
    public function getScoreColorAndName($score)
    {
        if ($score < 250) {
            $result['color'] = '#B82E03';
            $result['title'] = 'Плохой балл';
        } else {
            if ($score < 500) {
                $result['color'] = '#FFF500';
                $result['title'] = 'Средний балл';
            } else {
                $result['color'] = '#2A9A21';
                $result['title'] = 'Отличный балл';
            }
        }

        return $result;
    }

    /**
     * Цвет и наименование балла для шкалы в файлах рейтинга
     * @param $score
     * @return string[]
     */
    public function getColorForScoringFiles($score)
    {

        if (is_null($score)) {
            $result = [
               'color' => '#e20303',
               'title' => 'Идёт расчет кредитного рейтинга',
            ];
        } elseif ($score <= 125) {
            $result = [
                'color' => '#e20303',
                'title' => 'Очень низкий балл',
            ];
        } elseif ($score <= 275) {
            $result = [
                'color' => '#b82e03',
                'title' => 'Низкий балл',
            ];
        } elseif ($score <= 350) {
            $result = [
                'color' => '#b84f03',
                'title' => 'Средний балл',
            ];
        } elseif ($score <= 450) {
            $result = [
                'color' => '#F86801',
                'title' => 'Хороший балл',
            ];
        } elseif ($score <= 489) {
            $result = [
                'color' => '#FF9900',
                'title' => 'Очень хороший балл',
            ];
        } elseif ($score <= 600) {
            $result = [
                'color' => '#fff500',
                'title' => 'Отличный балл',
            ];
        } elseif ($score <= 675) {
            $result = [
                'color' => '#4BCD40',
                'title' => 'Прекрасный бaлл',
            ];
        } else {
            $result = [
                'color' => '#2a9f21',
                'title' => 'Великолепный бaлл',
            ];
        }

        return $result;
    }

    /**
     * Проверяет, был ли куплен кредитный рейтинг
     * @param int $user_id
     * @return bool
     */
    public function hasPayCreditRating(int $user_id): bool
    {
        $sql = "SELECT EXISTS (SELECT 
                    *
                FROM 
                    __transactions
                WHERE 
                    user_id = ? 
                    AND payment_type = 'credit_rating'
                    AND `status` IN('CONFIRMED', 'AUTHORIZED')) as result";

        $query = $this->db->placehold($sql, $user_id);
        $this->db->query($query);
        return (bool)$this->db->result('result');
    }

    public function get_scoring_body($id)
    {
        $query = $this->db->placehold("
            SELECT body 
            FROM __scoring_body
            WHERE scoring_id = ?
        ", (int)$id);
        $this->db->query($query);
        $result = $this->db->result('body');

        return $result;
    }

    public function add_scoring_body($id, string $body)
    {
        $this->db->query('INSERT INTO __scoring_body SET ?%', [
            'scoring_id' => $id,
            'body' => $body
        ]);
    }

    public function update_scoring_body($id, string $new_body)
    {
        $this->db->query("UPDATE __scoring_body SET `body` = ? WHERE scoring_id = ?", $new_body, $id);
    }

    /**
     * Останавливает все скоринги со статусом STATUS_NEW по id заявки
     *
     * @param int $orderId
     * @param array $updateData
     * @return void
     */
    public function stopOrderScorings(int $orderId, array $updateData): void
    {
        $updateData = [
            'status' => $this->scorings::STATUS_STOPPED,
            'string_result' => $updateData['string_result'] ?? '',
        ];

        $query = $this->db->placehold("
            UPDATE __scorings SET ?% WHERE order_id = ? AND status = ?
        ", $updateData, $orderId, self::STATUS_NEW);
        $this->db->query($query);

        // Останавливаем в заявке также скоринг TYPE_REPORT со статусом STATUS_WAIT
        $query = $this->db->placehold("
            UPDATE __scorings SET ?% WHERE order_id = ? AND type IN (?@) AND status = ?
        ", $updateData, $orderId, [self::TYPE_REPORT], self::STATUS_WAIT);
        $this->db->query($query);
    }

    private function tryAddScorista($order)
    {
        // Для запуска скористы нужен джусискор
        $juicescore = $this->scorings->getLastScoring([
            'user_id' => $order->user_id,
            'type' => self::TYPE_JUICESCORE
        ]);
        if (empty($juicescore)) {
            // Джуси должен был уже появиться, добавляем его если ещё нет
            $this->scorings->add_scoring([
                'user_id' => $order->user_id,
                'order_id' => $order->order_id,
                'type' => $this->scorings::TYPE_JUICESCORE
            ]);

            return false;
        }

        if (!in_array($juicescore->status, [self::STATUS_COMPLETED, self::STATUS_ERROR, self::STATUS_STOPPED])) {
            // Дожидаемся выполнения
            return false;
        }

        // Для запуска скористы нужен завершённый акси
        $axi = $this->scorings->getlastScoring([
            'order_id' => $order->order_id,
            'type' => self::TYPE_AXILINK_2
        ]);
        if (empty($axi) || $axi->status != self::STATUS_COMPLETED) {
            return false;
        }

        $this->scorings->add_scoring([
            'user_id' => $order->user_id,
            'order_id' => $order->order_id,
            'status' => self::STATUS_NEW,
            'created' => date('Y-m-d H:i:s'),
            'type' => self::TYPE_SCORISTA,
        ]);

        return true;
    }

    /**
     * Пытаемся добавить скористу и акси на заявку, если все нужные скоринги завершились удачно.
     * @param number|string $order_id
     * @return boolean
     */
    /**
     * Пытаемся добавить скористу и акси на заявку, если все нужные скоринги завершились удачно.
     * @param number|string $order_id
     * @return boolean
     */
    public function tryAddScoristaAndAxi($order_id): bool
    {
        $order = $this->orders->get_order($order_id);
        if (empty($order)) {
            return false;
        }

        $is_new_order = $order->status == $this->orders::ORDER_STATUS_CRM_NEW;
        $is_scorista_allowed = $this->scorings->isScoristaAllowed($order);
        if (!$is_new_order && $is_scorista_allowed) {
            return false;
        }

        if (in_array($order->utm_source, ['crm_auto_approve', 'cross_order'])) {
            return false;
        }

        // Для тестовых заявок идёт ручной запуск скористы и акси
        if ($this->user_data->read($order->user_id, $this->user_data::TEST_USER)) {
            return false;
        }

        $REQUIRED_FOR_SCORISTA = self::REQUIRED_FOR_SCORISTA_NK;
        if ($order->have_close_credits == 1) {
            $REQUIRED_FOR_SCORISTA = self::REQUIRED_FOR_SCORISTA_PK;
        }

        $scorings = $this->get_scorings([
            'order_id' => $order_id,
            'type' => $REQUIRED_FOR_SCORISTA
        ]);
        if (empty($scorings)) {
            return false;
        }

        // Формируем массив из самых актуальных скорингов
        $last_scorings = [];
        foreach ($scorings as $scoring) {
            if (empty($last_scorings[$scoring->type])) {
                $last_scorings[$scoring->type] = $scoring;
                continue;
            }

            if ($last_scorings[$scoring->type]->id < $scoring->id) {
                // Этот скоринг новее, сохраним его, а старый уберём
                $last_scorings[$scoring->type] = $scoring;
            }
        }

        $required_scorings = array_fill_keys($REQUIRED_FOR_SCORISTA, false);

        $has_scorista = $has_axi = false;
        foreach ($last_scorings as $type => $scoring) {
            $required_scorings[$type] = true;

            if ($type == self::TYPE_SCORISTA) {
                $has_scorista = true;
                if ($has_axi) // И скориста и акси уже добавлены, нет смысла проверять дальше
                    return false;
                continue;
            }

            if ($type == self::TYPE_AXILINK_2) {
                $has_axi = true;
                if ($has_scorista) // И акси и скориста уже добавлены, нет смысла проверять дальше
                    return false;
                continue;
            }

            // Если один из важных скорингов не готов или завершился с ошибкой - не запускаем скористу и акси
            if ($scoring->status != self::STATUS_COMPLETED) {
                return false;
            }

            // Если один из скорингов не прошёл - не запускаем скористу и акси
            // Не смотрим на результат выполнения Регион IP
            if ($scoring->success == 0 && $type != $this->scorings::TYPE_LOCATION_IP) {
                return false;
            }
        }

        // Все ли нужные скоринги отмечены как найденные
        if ($order->have_close_credits == 0) {
            // Проверяем только для НК, как было раньше
            unset($required_scorings[self::TYPE_SCORISTA], $required_scorings[self::TYPE_AXILINK_2]);
            if (in_array(false, $required_scorings, true)) {
                // Не все, ждём их добавления
                return false;
            }
        }

        if (!$has_axi) {
            $new_axi = [
                'user_id' => $order->user_id,
                'order_id' => $order_id,
                'status' => self::STATUS_NEW,
                'created' => date('Y-m-d H:i:s'),
                'type' => self::TYPE_AXILINK_2,
            ];
            $this->scorings->add_scoring($new_axi);
        }

        if ($has_axi && !$has_scorista) {
            return $this->tryAddScorista($order);
        }

        return true;
    }

    public function get_body_by_type($scoring)
    {
        switch ($scoring->type) {
            case self::TYPE_FSSP:
            case self::TYPE_BLACKLIST:
            case self::TYPE_JUICESCORE:
            case self::TYPE_EGRUL:
                return $this->get_unserialized_body($scoring->id);
            case self::TYPE_AXILINK:
            case self::TYPE_SCORISTA:
            case self::TYPE_DBRAIN_PASSPORT:
            case self::TYPE_DBRAIN_CARD:
            case self::TYPE_AXILINK_2:
            case self::TYPE_FINKARTA:
                return $this->get_json_decoded_body($scoring->id);
            case self::TYPE_EFRSB:
                return $this->get_scoring_body($scoring->id);
            default:
                return null;
        }
    }

    protected function get_unserialized_body(int $scoringId)
    {
        $body = $this->get_scoring_body($scoringId);
        if (empty($body))
            return $body;

        return unserialize($body);
    }

    protected function get_json_decoded_body(int $scoringId)
    {
        $body = $this->get_scoring_body($scoringId);
        $body = json_decode($body);
        if (!empty($body->equifaxCH)) {
            $body->equifaxCH = iconv('cp1251', 'utf8', base64_decode($body->equifaxCH));
        }

        return $body;
    }

    /**
     * Получение последнего скоринга подходящего под заданные критерии.
     *
     * Пример:
     * ```
     * $scoring = $this->simpla->getLastScoring([
     *  'order_id' => 2489,
     *  'success' => 0,
     * ]);
     * ```
     * @param array $where
     * @return false|object
     */
    public function getLastScoring(array $where)
    {
        $conditions = [];
        foreach ($where as $condition => $value) {
            $conditions[] = $this->db->placehold("`$condition` = ?", $value);
        }

        $conditions = implode(' AND ', $conditions);
        $this->db->query("SELECT * FROM __scorings WHERE $conditions ORDER BY id DESC LIMIT 1");
        $result = $this->db->result();
        if (!empty($result))
            $result->body = $this->get_scoring_body($result->id);
        return $result;
    }

    /**
     * Получение причины отказа по строке стоп-факторов
     * @param $user_id
     * @param string $factors_string Строка стоп-факторов из ответа акси
     * @return false|int
     */
    public function getAxiRejectReason($user_id, string $factors_string)
    {
        if (empty($factors_string))
            return false;

        // Первый стоп-фактор в списке
        $reason_key = explode(";", $factors_string, 2)[0];
        $reason_id = (int)(self::AXI_REJECT_REASONS[$reason_key] ?? $this->reasons::REASON_SCORISTA);

        // Отдельная логика для не найденного ИНН
        if ($reason_id == $this->reasons::REASON_INN_NOT_FOUND) {
            if ($this->user_data->read($user_id, 'inn_not_found') == 1) {
                // ИНН не найден во второй раз, отправляем в автоотказ
                return $reason_id;
            }

            // ИНН не найден в первый раз, автоотказа нет
            $this->user_data->set($user_id, 'inn_not_found', 1);
            return false;
        }

        // ИНН найден, убираем плашку с предупреждением
        $this->user_data->set($user_id, 'inn_not_found', 0);

        return $reason_id;
    }

    const SCORISTA_DISABLED_SOURCES = [
        'bankiru',
        'finuslugi',
        //'sravni',
        //'c2m',
        //'leadstech',
    ];

    /**
     * Может ли скориста сделать автоотказ или изменить сумму в заявке.
     *
     * Для теста СПР Акси скориста не может влиять на НК с определёнными источниками
     * @param stdClass $order
     * @return bool
     * @see SCORISTA_DISABLED_SOURCES
     */
    public function isScoristaAllowed($order)
    {
        $axi_spr_enabled = $this->settings->axi_spr_enabled;
        if (empty($axi_spr_enabled))
            return true;

        if (in_array($order->utm_source, self::SCORISTA_DISABLED_SOURCES) && $order->have_close_credits == 0) {
            $order_id = $order->id ?? $order->order_id;
            $this->order_data->set($order_id, 'axi_spr', '1');
            return false;
        }

        return true;
    }

    /**
     * Получает выполненные успешно скоринги
     * @param int $user_id
     * @param array $types
     * @return false|int
     */
    public function getCompleteScoringByTypes(int $user_id, array $types)
    {
        $query = $this->db->placehold(
            "SELECT * FROM __scorings WHERE type IN(?@) AND user_id = ? AND status = ? AND success = 1 ORDER BY id DESC LIMIT 1",
            $types,
            $user_id,
            self::STATUS_COMPLETED
        );
        $this->db->query($query);
        return $this->db->result();
    }

    /**
     * Получает одобренную сумму по скорингам
     * @param int $user_id
     * @return int|null
     */
    public function getApproveAmountScoring(int $user_id): ?int
    {
        // проверяем скористу
        $scoring = $this->getCompleteScoringByTypes($user_id, [self::TYPE_AXILINK, self::TYPE_SCORISTA, self::TYPE_AXILINK_2]);
        if (!empty($scoring)) {
            $body = $this->get_body_by_type($scoring);
            switch ($scoring->type) {
                case self::TYPE_AXILINK:
                    return (int)$body->sum;
                case self::TYPE_SCORISTA:
                    return (int)$body->additional->decisionSum;
                case self::TYPE_AXILINK_2:
                    return (int)$body->final_limit;
            }
        }
        return null;
    }

    /**
     * Скоринги после персональных данных
     * @return int[]
     */
    public static function getScoringListAfterPersonalData(): array
    {
        return [
            self::TYPE_UPRID,
            self::TYPE_FNS,
            self::TYPE_EFRSB,
        ];
    }

    /**
     * Скоринги после подачи заявки НК
     * @return int[]
     */
    public static function getScoringListAfterNewOrder(): array
    {
        return [
            self::TYPE_BLACKLIST,
            self::TYPE_AGE,
        ];
    }
}
